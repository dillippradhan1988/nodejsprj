1135

to set & get port no 
	app.set(port, process.env.PORT || 3000)
	app.get('port')

nodejs			express
------          -------
res.end			res.send
res.writeHead	res.set

"use" is the method by which Express addsmiddleware.

Express can distinguish between the 404 and 500 handlers by the number of arguments
their callback functions take

middleware provides modularization, making it easier to handle requests.

The
caret (^) in front of the package versions indicates that any version that starts with the
specified version number—up to the next major version number—will work

"run npm install" to reinstall all modules that is added in package.json

Node modules, as the name implies, offer a mechanism for modularization and
encapsulation. npm packages provide a standardized scheme for storing, versioning,
and referencing projects (which are not restricted to modules)

if you want something to be visible outside of the module, you have to add it to exports .
This is a good thing: encapsulation allows for less error-prone and fragile code.
var fortune = require('./lib/fortune.js');
"./" signals to Node that it should not



http://localhost:3000/about?test=1#history
	http:// 		=>	protocol
	localhost		=>	host
	:3000			=>	port
	/about			=>	path
	?test=1			=>	querystring
	#history		=>	fragment

Protocol
	The protocol determines how the request will be transmitted. We will be dealing
	exclusively with http and https. Other common protocols include file and ftp.
Host
	The host identifies the server. Servers on your computer (localhost) or a local net‐
	work may simply be one word, or it may be a numeric IP address. On the Internet,
	the host will end in a top-level domain (TLD) like .com or .net. Additionally, there
	may be subdomains, which prefix the hostname. www is a very common subdo‐
	main, though it can be anything. Subdomains are optional.
Port
	Each server has a collection of numbered ports. Some port numbers are “special,”
	like 80 and 443. If you omit the port, port 80 is assumed for HTTP and 443 for
	HTTPS. In general, if you aren’t using port 80 or 443, you should use a port number
	greater than 1023. 1 It’s very common to use easy-to-remember port numbers like
	3000, 8080, and 8088.
Path
	The path is generally the first part of the URL that your app cares about (it is possible
	to make decisions based on protocol, host, and port, but it’s not good practice). The
	path should be used to uniquely identify pages or other resources in your app.
Querystring
	The querystring is an optional collection of name/value pairs. The querystring
	starts with a question mark (?), and name/value pairs are separated by ampersands
	(&). Both names and values should be URL encoded. JavaScript provides a built-in
	function to do that: encodeURIComponent . For example, spaces will be replaced with
	plus signs (+). Other special characters will be replaced with numeric character
	references.
Fragment
	The fragment (or hash) is not passed to the server at all: it is strictly for use by the
	browser. It is becoming increasingly common for single-page applications or AJAX-
	heavy applications to use the fragment to control the application. Originally, the
	fragment’s sole purpose was to cause the browser to display a specific part of the
	document, marked by an anchor tag ( <a id="chapter06"> )
Ports 0-1023 are “well-known ports.”

Disabling Express’s default X-Powered-By header is easy:
	app.disable('x-powered-by');
The format of the Content-Type header is
an Internet media type, which consists of a type, subtype, and optional parameters. For
example, text/html; charset=UTF-8 specifies a type of “text,” a subtype of “html,” and
a character encoding of UTF-8

The most common media type for POST bodies is
application/x-www-form-urlencoded , which is simply encoded name/value pairs
multipart/form-data     file upload
application/json		ajax request
separated by ampersands

The Request Object
----------------------------------------
The request object (which is normally passed to a callback, meaning you can name it
whatever you want: it is common to name it req or request ) starts its life as an instance
of http.IncomingMessage , a core Node object.
req.headers and req.url node method
	req.params
	req.query
	req.body
	req.route
	req.cookies / req.signedCookies
	req.headers
	req.accepts([types])
	req.ip
	req.path
	req.host
	req.xhr
	req.protocol
	req.secure	
	req.url / req.originalUrl
	req.acceptedLanguages

The Response Object
-----------------------------------------
The response object (which is normally passed to a callback, meaning you can name it
whatever you want: it is common to name it res , resp , or response ) starts its life as an
instance of http.ServerResponse , a core Node object
	res.status(code)
	res.set(name, value)
	res.cookie(name, value, [options]) , res.clearCookie(name, [options])
	res.redirect([status], url)
	res.send(body) , res.send(status, body)
	res.json(json) , res.json(status, json)
	res.jsonp(json) , res.jsonp(status, json)
	res.type(type)
	res.format(object)
	res.attachment([filename]) , res.download(path, [filename], [callback])
	res.sendFile(path, [options], [callback])
	res.links(links)
	res.locals , res.render(view, [locals], callback)

Express source
-----------------------------------------------
lib/application.js
	The main Express interface. If you want to understand how middleware is linked
	in, or how views are rendered, this is the place to look.
lib/express.js
	This is a relatively short shell that extends Connect with the functionality in lib/
	application.js, and returns a function that can be used with http.createServer to
	actually run an Express app.
lib/request.js
	Extends Node’s http.IncomingMessage object to provide a robust request object.
	For information about all the request object properties and methods, this is where
	to look.
lib/response.js
	Extends Node’s http.ServerResponse object to provide the response object. For
	information about response object properties and methods, this is where to look.
lib/router/route.js
	Provides basic routing support. While routing is central to your app, this file is less
	than 200 lines long; you’ll find that it’s quite simple and elegant.

app.set('view cache', true);
require('express3-handlebars').create({ extname: '.hbs' })
{{> partial_name}} //including parial in view

Default form submission encoding
	application/x-www-form-urlencoded

It’s very important that you use a 303 (or 302) redirect, not a 301
redirect in this instance. 301 redirects are “permanent,” meaning your
browser may cache the redirection destination. If you use a 301 redi‐
rect and try to submit the form a second time, your browser may
bypass the /process handler altogether and go directly to /thank-
you since it correctly believes the redirect to be permanent. The 303
redirect, on the other hand, tells your browser “Yes, your request is
valid, and you can find your response here,” and does not cache the
redirect destination.

cookie
	The idea of a cookie is simple: the server sends a bit of information, and the browser
	stores it for some configurable period of time. It’s really up to the server what the par‐
	ticular bit of information is: often it’s just a unique ID number that identifies a specific
	browser so that the illusion of state can be maintained.

	A category of attacks called cross-site scripting attacks (XSS) has sprung up in recent
	years. One technique of XSS attacks involves malicious JavaScript modifying the
	contents of cookies

	Cookies are not magic: when the server wishes the client to store a
	cookie, it sends a header called Set-Cookie containing name/value
	pairs, and when a client sends a request to a server for which it has
	cookies, it sends multiple Cookie request headers containing the val‐
	ue of the cookies.

	res.cookie('monster', 'nom nom');
	res.cookie('signed_monster', 'nom nom', { signed: true });

	var monster = req.cookies.monster;
	var signedMonster = req.signedCookies.monster;

	To delete a cookie, use req.clearCookie :
	res.clearCookie('monster');
session
	Broadly speaking, there are two ways to implement sessions: store everything in the
	cookie,called “cookie-based sessions.”cookie-session middleware

	or store only a unique identifier in the cookie and everything else on the serv‐
	er. 

	The express-session middleware accepts a configuration object with the following
	options:
	key
	The name of the cookie that will store the unique session identifier. Defaults to
	connect.sid .
	store
	An instance of a session store. Defaults to an instance of MemoryStore , which is fine
	for our current purposes. We’ll see how to use a database store in Chapter 13.
	cookie
	Cookie settings for the session cookie ( path , domain , secure , etc.). Regular cookie
	defaults apply.

	req.session.userName = 'Anonymous';
var colorScheme = req.session.colorScheme || 'dark';

	req.session.userName = null; // this sets 'userName' to null,
	// but doesn't remove it
	delete req.session.colorScheme; // this removes 'colorScheme'

middleware
	Conceptually, middleware is a way to encapsulate functionality: specifically, function‐
	ality that operates on an HTTP request to your application. Practically, a middleware is
	simply a function that takes three arguments: a request object, a response object, and a
	“next” function, which will be explained shortly. (There is also a form that takes four
	arguments, for error handling, which will be covered at the end of this chapter.)

	In an Express app, you insert middleware into the pipeline by
	calling app.use .

	. If there are two or three parameters, the first two
	parameters are the request and response objects, and the third paramater is the
	next function. If there are four parameters, it becomes an error-handling middle‐
	ware, and the first parameter becomes an error object, followed by the request,
	response, and next objects.

	• If you don’t call next() , the pipeline will be terminated, and no more route handlers
	or middleware will be processed. If you don’t call next() , you should send a re‐
	sponse to the client ( res.send , res.json , res.render , etc.); if you don’t, the client
	will hang and eventually time out.

	• If you do call next() , it’s generally inadvisable to send a response to the client. If
	you do, middleware or route handlers further down the pipeline will be executed,
	but any client responses they send will be ignored.	

	In the previous example, we have a middleware aborting early with
	the statement return next() . Express doesn’t expect middleware to
	return a value (and it doesn’t do anything with any return values), so
	this is just a shortened way of writing next(); return; .

Mial
	SMTP, MSAs, and MTAs
		The lingua franca for sending email is the Simple Mail Transfer Protocol (SMTP). While
		it is possible to use SMTP to send an email directly to the recipient’s mail server, this is
		generally a very bad idea: unless you are a “trusted sender” like Google or Yahoo!,
		chances are your email will be be tossed directly into the spam bin. 
		
		Better to use a Mail Submission Agent (MSA), which will deliver the email through
		trusted channels, reducing the chance that your email will be marked as spam.
		In addition to ensuring that your email arrives, MSAs handle nuisances like 
		temporary outages and bounced emails.
		
		The final piece of the equation is the Mail Transfer Agent (MTA), which is the service
		that actually sends the email to its final destination
	Receiving Email
		Unfortunately, receiving email is much more involved and will not be covered in this
		book. If this is functionality you need, you should look into Andris Reinman’s SimpleSMTP
		or Haraka.
		https://github.com/andris9/simplesmtp
		http://haraka.github.io/
	Email Headers
		An email message consists of two parts: the header and the body (very much like an
		HTTP request). The header contains information about the email: who it’s from, who
		it’s addressed to, the date it was received, the subject, and more.
		
		The headers give you all the information about how the
		email got to you; every server and MTA that the email passed through will be listed in
		the header.
		
		When you specify a “from” address other than the account
		from which you’re sending, it’s often referred to as “spoofing.”
	Email Formats
		email can either be plaintext (Unicode) or HTML.
		
		http://kb.mailchimp.com/campaigns/ways-to-build/about-html-email
	
	Syntax:
		var mailTransporter = nodemailer.createTransport(options[, defaults]);
	
	//node mailer package
		var nodemailer 		= 	require('nodemailer');
	
	//3 type SMTP config setting (options)
		var smtpConfig = {
		    host: 'smtp.gmail.com',
		    port: 465,
		    secure: true, // use SSL
		    auth: {
		        user: 'user@gmail.com',
		        pass: 'pass'
		    }
		};
		
		var poolConfig = {
		    pool: true,
		    host: 'smtp.gmail.com',
		    port: 465,
		    secure: true, // use SSL
		    auth: {
		        user: 'user@gmail.com',
		        pass: 'pass'
		    }
		};
		
		var directConfig = {
		    name: 'hostname' // must be the same that can be reverse resolved by DNS for your IP
		};
	
	Alternatively you could use connection url. Use smtp:, smtps: or direct: as the protocol.

		var smtpConfig = 'smtps://user%40gmail.com:pass@smtp.gmail.com';
		var poolConfig = 'smtps://user%40gmail.com:pass@smtp.gmail.com/?pool=true';
		var directConfig = 'direct:?name=hostname';
	
	
	
	Example
		//using Mail Submission Agent (MSA) like Gmail
		var smtpConfig 		= 	{
			    host: 'smtp.gmail.com',
			    port: 465,
			    secure: true, // use SSL
			    auth: {
			        user: credentials.gmail.user,
			        pass: credentials.gmail.password
			    }
		};
		
		var mailTransporter = 	nodemailer.createTransport(smtpConfig);
		
		app.get('/sendmail',function(req,res){
			// setup e-mail data with unicode symbols
			var mailOptions = {
			    from: '"Fred Foo ??" <foo@blurdybloop.com>', // sender address
			    to: 'bar@blurdybloop.com, baz@blurdybloop.com', // list of receivers
			    subject: 'Hello ?', // Subject line
			    text: 'Hello world ??', // plaintext body
			    html: '<b>Hello world ??</b>' // html body
			};
			
			// send mail with defined transport object
			mailTransporter.sendMail(mailOptions, function(error, info){
			    if(error){
			        return console.log(error);
			    }
			    console.log('Message sent: ' + info.response);
			    res.send('Mail sent successfully.');
			});
		});
		
		The difference between an attachment and an alternative is the fact that attachments are placed into multipart/mixed or multipart/related parts of the message 
		white alternatives are placed into multipart/alternative part.